// Test_EventLogic.cpp : Defines the entry point for the console application.
//
#include "stdafx.h"

/**
* Store the number of interrupt that occured
**/
int interruptNb = 0;

/**
* Interrupt routine used this sample
**/
void CustomizedInterruptRoutine (HANDLE deviceHandle,
								 BYTE	fifoOverflow,
								 BYTE	interruptSource,
								 WORD	args )
{
	UNREFERENCED_PARAMETER(deviceHandle);
	UNREFERENCED_PARAMETER(args);

	/* check for overflow */
	if ( fifoOverflow != 0 )
	{
		printf("Interrupt fifo is in overflow mode. Your software do not handle interrupt fast enough.\n");
	}

	/* interrupt generated by an event on port 0 ? */
	if ( interruptSource & 0x01 )
	{
		interruptNb++;
	}
}

int _tmain(int /* argc */, _TCHAR* /* argv[] */)
{
	INT returnValue = 0;
	HANDLE	boardHandle = NULL;

	/* call the util method to open a board */
	returnValue = OpenBoard(&boardHandle);
	if (returnValue != 0)
	{
		printf("Error while opening the board : %d \n", (int) returnValue);
		_getch();
		return -1;
	}

	/* display some useful informations */
	printf("* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * \n");
	printf("* Event logic sample. \n");
	printf("* This sample enables to test the maximum frequency for the event logic. \n");
	printf("* It uses event on the port A, with the OR logic and the following mask: \n");
	printf("* XXXXXXX0 => Event is generated when input 0 is set to 0. \n");
	printf("* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * \n\n");

	/* set the interrupt routine */
	returnValue = i_PCI1500_SetBoardIntRoutine(boardHandle, CustomizedInterruptRoutine);
	if ( returnValue != 0 )
	{
		printf("Error %d in i_PCI1500_SetBoardIntRoutine \n", returnValue);
		i_PCI1500_CloseBoard(boardHandle);
		_getch();
		return -1;
	}
	printf("i_PCI1500_SetBoardIntRoutine : successful\n");

	/* Initialize the event logic */
	returnValue = i_PCI1500_InitEventLogic(boardHandle,0,0,"XXXXXXX0");
	if ( returnValue != 0 )
	{
		printf("Error %d in i_PCI1500_InitEventLogic \n", returnValue);
		i_PCI1500_ResetBoardIntRoutine(boardHandle);
		i_PCI1500_CloseBoard(boardHandle);
		_getch();
		return -1;
	}
	printf("i_PCI1500_InitEventLogic : successful\n");

	/* start the event logic */
	returnValue = i_PCI1500_StartEventLogic(boardHandle,0);
	if ( returnValue != 0 )
	{
		printf("Error %d in i_PCI1500_StartEventLogic \n", returnValue);
		i_PCI1500_ResetBoardIntRoutine(boardHandle);
		i_PCI1500_CloseBoard(boardHandle);
		_getch();
		return -1;
	}
	printf("i_PCI1500_StartEventLogic : successful\n");

	printf("The board is now waiting an event. Press any key to exit this sample.\n");
	/*
	* Wait that the user hit a key 
	* The displaying is now done in the Utils.cpp file (interrupt routine)
	*/
	for(;;)
	{
		Sleep(100);
		if ( _kbhit() )
		{
			_getch();
			break;
		}
		printf("NB interrupt : %d \t\r", interruptNb);
	}

	/* stop the event logic */
	returnValue = i_PCI1500_StopEventLogic(boardHandle, 0);
	if ( returnValue != 0 )
	{
		printf("Error %d in i_PCI1500_StopEventLogic \n", returnValue);
	}
	else
	{
		printf("i_PCI1500_StopEventLogic : successful\n");
	}

	/* reset the interrupt routine */
	returnValue = i_PCI1500_ResetBoardIntRoutine(boardHandle);
	if ( returnValue != 0 )
	{
		printf("Error %d in i_PCI1500_ResetBoardIntRoutine \n", returnValue);
	}
	else
	{
		printf("i_PCI1500_ResetBoardIntRoutine : successful\n");
	}

	/* release the board */
	returnValue = i_PCI1500_CloseBoard(boardHandle);
	if ( returnValue != 0 )
	{
		printf("Error %d in i_PCI1500_CloseBoard \n", returnValue);
	}
	else
	{
		printf("i_PCI1500_CloseBoard : successful\n");
	}


	/* exit */
	printf("\n Press any key to exit the sample ...");
	_getch();
	return 0;
}

