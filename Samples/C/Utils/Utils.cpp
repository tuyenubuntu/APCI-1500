#include "Utils.h"

#include "..\Include\PCI1500.h"

#define PROGRESS_LENGTH 5

/**
* Interrupt routine used for several software
**/
void InterruptRoutine (HANDLE deviceHandle,
					   BYTE	fifoOverflow,
					   BYTE	interruptSource,
					   WORD	args )
{
	UNREFERENCED_PARAMETER(deviceHandle);

	/* check for overflow */
	if ( fifoOverflow != 0 )
	{
		printf("Interrupt fifo is in overflow mode. Your software do not handle interrupt fast enough.\n");
	}

	/* interrupt generated by an event on port 0 ? */
	if ( interruptSource & 0x01 )
	{
		printf("Event on port 0, inputs = 0x%x\n", args);
	}

	/* interrupt generated by an event on port 1 ? */
	if ( interruptSource & 0x02 )
	{
		printf("\n Event on port 1, inputs = 0x%x\n", args);
	}

	/* timer 0 interrupt ? */
	if ( interruptSource & 0x04 )
	{
		printf("Timer/Counter 0 interrupt.\n");
	}

	/* timer 1 interrupt ? */
	if ( interruptSource & 0x08 )
	{
		printf("Timer/Counter 1 interrupt.\n");
	}

	/* timer 2 interrupt ? */
	if ( interruptSource & 0x10 )
	{
		printf("Watchdog/Counter 2 interrupt.\n");
	}

	/* watchdog interrupt ? */
	if ( interruptSource & 0x20 )
	{
		printf("Watchdog 2 interrupt.\n");
	}

	/* vcc interrupt (no more alimentation) */
	if ( interruptSource & 0x40 )
	{
		printf("Voltage interrupt.\n");
	}

	/* short-circuit interrupt */
	if ( interruptSource & 0x80 )
	{
		printf("Short-circuit interrupt.\n");
	}
}

/**
* Enable to read a ulong from the keyboard
* @param description: A description string that is printed to give some information about the value that must be given
**/
void ReadUlong( char* description, ULONG minValue, ULONG maxValue, ULONG* readValue )
{
	do
	{
		printf("%s", description);
		_flushall();
		scanf_s("%u", readValue );
	}
	while( (*readValue < minValue) || (*readValue > maxValue) );
}

/**
* Enable to display informations about a board, given its index
**/
static INT DisplayBoardInformations ( BYTE boardIndex )
{
	INT returnValue = 0;
	HANDLE boardHandle = NULL;
	DWORD identifierSize = 50;
	CHAR identifier[50] = {0};
	DWORD uiNumber = 0;
	DWORD deviceNumber = 0;
	DWORD busNumber = 0;
	DWORD baseAddress0 = 0;
	DWORD baseAddress1 = 0;
	DWORD baseAddress2 = 0;
	BYTE interrupt = 0;
	DWORD deviceDriverVersion = 0;

	/* Get informations about the board */
	returnValue = i_PCI1500_GetBoardInformation(boardIndex,
							identifierSize,
							identifier,
							&uiNumber,
							&deviceNumber,
							&busNumber,
							&baseAddress0,
							&baseAddress1,
							&baseAddress2,
							&interrupt);

	/* Error handling */
	if ( returnValue != 0 )
	{
		printf("error getting board information : %d \n", returnValue);
		return -1;
	}

	/* 
	* Open an handle to the board 
	* That will enable to get the version of the device driver applied to this device
	*/
	returnValue = i_PCI1500_OpenBoardViaIndex(boardIndex, &boardHandle);

	/* Error handling */
	if ( returnValue != 0 )
	{
		printf("error opening board : %d \n", returnValue);
		return -2;
	}

	/* Get the driver version */
	returnValue = i_PCI1500_GetDeviceDriverVersion(boardHandle, &deviceDriverVersion );
	if ( returnValue != 0 )
	{
		printf("error getting device driver version : %d \n", returnValue);
		return -3;
	}

	/* Display informations about the board */
	printf("**********************************************\n");
	printf("Board index : %d \n", boardIndex);
	printf("Identifier : %s \n", identifier);
	printf("Base address 0 : %x \n", baseAddress0);
	printf("Base address 1 : %x \n", baseAddress1);
	printf("Base address 2 : %x \n", baseAddress2);
	printf("UI Number : %d \n", (int)uiNumber);
	printf("Device Number : %d \n", (int)deviceNumber);
	printf("Bus Number : %d \n", (int)busNumber);
	printf("Interrupt line : %d \n", interrupt);
	printf("Device driver version : 0x%0.8x \n", (int)deviceDriverVersion);

	/* Close the board */
	returnValue = i_PCI1500_CloseBoard(boardHandle);
	if ( returnValue != 0 )
	{
		printf("error closing the board: %d \n", returnValue);
		return -4;
	}

	return 0;
}

/**
* Method used to check that the index given by the user is correct
**/
static inline BOOL IsIndexCorrect ( BYTE boardNbr, int index)
{
	if ( index < 0 )
	{
		return FALSE;
	}
	if ( index >= boardNbr )
	{
		return FALSE;
	}
	return TRUE;
}

/**
* Enable to open a board via index
* The index is asked to the user
**/
static INT OpenBoardViaIndex( HANDLE * deviceHandle , BYTE boardNbr )
{
	INT returnValue = 0;
	int boardIndex = 0xFF;

	/* Get the index from the user */
	do
	{
		printf("Select the board you want to use (0 to %d) ", (int)(boardNbr-1));
		_flushall();
		scanf_s("%d",&boardIndex);
	} while ( IsIndexCorrect( boardNbr, boardIndex ) == FALSE );

	/* Open the board */
	returnValue = i_PCI1500_OpenBoardViaIndex( (BYTE)boardIndex, deviceHandle);

	/* error handling */
	if ( returnValue != 0 )
	{
		printf("Error while opening the board via index : %d \n", returnValue );
		return -1;
	}

	/* success */
	return 0;
}

/**
* Enable to open a board via identifier
* The identifier is asked to the user
**/
static INT OpenBoardViaIdentifier ( HANDLE * deviceHandle )
{
	INT returnValue = 0;
	CHAR identifierChoice[50] = {0};

	/* Ask for the identifier choice */
	printf("Enter the selected identifier : ");
	_flushall();
	scanf_s("%s",identifierChoice);

	returnValue = i_PCI1500_OpenBoardViaIdentifier( identifierChoice, deviceHandle);
	
	/* Error handling */
	if ( returnValue != 0 )
	{
		printf("error opening board via identifier: %d \n", returnValue);
		return -1;
	}

	/* success */
	return 0;
}

/**
* Enables to give to the user the choice to open a board
* The function also enables (first) to display informations about the available boards
**/
INT OpenBoard(HANDLE * deviceHandle)
{
	BYTE boardNbr = 0;
	INT returnValue = 0;
	DWORD dllVersion = 0;
	BYTE i = 0;
	int openMode = -1;

	/* Get the version of the DLL */
	returnValue = i_PCI1500_GetDLLVersion( &dllVersion );
	
	/* Error handling */
	if ( returnValue != 0 )
	{
		printf("error getting the DLL's version : %d \n", returnValue);
		return -1;
	}
	/* Print the DLL version */
	printf("DLL version : 0x%0.8x \n", (int)dllVersion);

	/* Get the number of boards available */
	returnValue = i_PCI1500_GetNumberOfBoards( &boardNbr );

	/* Error handling */
	if ( returnValue != 0 )
	{
		printf("error getting number of boards : %d \n", returnValue);
		return -2;
	}

	/* Check the number of board */
	if (boardNbr == 0)
	{
		printf("Error : no board found \n");
		return -3;
	}

	/* Loop through all the boards to display useful informations */
	for (i = 0; i < boardNbr; i++)
	{
		/* Display informations about the board */
		returnValue = DisplayBoardInformations(i);

		if ( returnValue != 0 )
		{
			printf("Error displaying board informations : %d \n", (int)returnValue);
			return -4;
		}
	}

	/* Ask opening mode : index or identifier */
	do
	{
		printf("Do you want to open the driver via index (0) or via identifier (1): ");
		_flushall();
		scanf_s("%d",&openMode);
	} while ( (openMode != 0) && (openMode != 1) );

	/* call the correct function */
	switch ( openMode )
	{
		case 0:
			return OpenBoardViaIndex( deviceHandle, boardNbr );
		case 1:
			return OpenBoardViaIdentifier( deviceHandle );
		default:
			/* unknown mode */
			return -1;
	}
}

/**
* Display a sort of progress bar
**/
void DisplayRunningStatus()
{
	static int charNbr = 0;
	int i = 0;

	/* display running status */
	for ( i = 0; i < PROGRESS_LENGTH; i++ )
	{
		if ( i < charNbr ) 
		{
			printf(".");
		}
		else
		{
			printf(" ");
		}
	}
	printf("\r");
	charNbr = ( charNbr > PROGRESS_LENGTH ) ? 0 : charNbr + 1;
}